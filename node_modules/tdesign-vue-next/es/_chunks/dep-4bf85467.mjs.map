{"version":3,"file":"dep-4bf85467.mjs","sources":["../../../common/js/qrcode/qrcodegen.ts","../../../common/js/qrcode/utils.ts","../../../components/qrcode/hooks/useQRCode.ts"],"sourcesContent":["/* eslint-disable */\n// Copyright (c) Project Nayuki. (MIT License)\n// https://www.nayuki.io/page/qr-code-generator-library\n\n// Modification with code reorder and prettier\n\n// --------------------------------------------\n\n// Appends the given number of low-order bits of the given value\n// to the given buffer. Requires 0 <= len <= 31 and 0 <= val < 2^len.\nfunction appendBits(val: number, len: number, bb: number[]): void {\n  if (len < 0 || len > 31 || val >>> len !== 0) {\n    throw new RangeError(\"Value out of range\");\n  }\n  for (\n    let i = len - 1;\n    i >= 0;\n    i-- // Append bit by bit\n  ) {\n    bb.push((val >>> i) & 1);\n  }\n}\n\n// Returns true iff the i'th bit of x is set to 1.\nfunction getBit(x: number, i: number): boolean {\n  return ((x >>> i) & 1) !== 0;\n}\n\n// Throws an exception if the given condition is false.\nfunction assert(cond: boolean): void {\n  if (!cond) {\n    throw new Error(\"Assertion error\");\n  }\n}\n\n/* ---- Public helper enumeration ----*/\n/*\n * Describes how a segment's data bits are numbererpreted. Immutable.\n */\nexport class Mode {\n  /* -- Constants --*/\n\n  public static readonly NUMERIC = new Mode(0x1, [10, 12, 14]);\n\n  public static readonly ALPHANUMERIC = new Mode(0x2, [9, 11, 13]);\n\n  public static readonly BYTE = new Mode(0x4, [8, 16, 16]);\n\n  public static readonly KANJI = new Mode(0x8, [8, 10, 12]);\n\n  public static readonly ECI = new Mode(0x7, [0, 0, 0]);\n\n  /* -- Constructor and fields --*/\n\n  // The mode indicator bits, which is a unumber4 value (range 0 to 15).\n  public modeBits: number;\n\n  // Number of character count bits for three different version ranges.\n  private numBitsCharCount: [number, number, number];\n\n  private constructor(\n    modeBits: number,\n    numBitsCharCount: [number, number, number]\n  ) {\n    this.modeBits = modeBits;\n    this.numBitsCharCount = numBitsCharCount;\n  }\n\n  /* -- Method --*/\n\n  // (Package-private) Returns the bit width of the character count field for a segment in\n  // this mode in a QR Code at the given version number. The result is in the range [0, 16].\n  public numCharCountBits(ver: number): number {\n    return this.numBitsCharCount[Math.floor((ver + 7) / 17)];\n  }\n}\n\n/* ---- Public helper enumeration ----*/\n\n/*\n * The error correction level in a QR Code symbol. Immutable.\n */\nexport class Ecc {\n  /* -- Constants --*/\n\n  public static readonly LOW = new Ecc(0, 1); // The QR Code can tolerate about  7% erroneous codewords\n\n  public static readonly MEDIUM = new Ecc(1, 0); // The QR Code can tolerate about 15% erroneous codewords\n\n  public static readonly QUARTILE = new Ecc(2, 3); // The QR Code can tolerate about 25% erroneous codewords\n\n  public static readonly HIGH = new Ecc(3, 2); // The QR Code can tolerate about 30% erroneous codewords\n\n  /* -- Constructor and fields --*/\n  // In the range 0 to 3 (unsigned 2-bit numbereger).\n  public ordinal: number;\n\n  // (Package-private) In the range 0 to 3 (unsigned 2-bit numbereger).\n  public formatBits: number;\n\n  private constructor(ordinal: number, formatBits: number) {\n    this.ordinal = ordinal;\n    this.formatBits = formatBits;\n  }\n}\n\n/*\n * A segment of character/binary/control data in a QR Code symbol.\n * Instances of this class are immutable.\n * The mid-level way to create a segment is to take the payload data\n * and call a static factory function such as QrSegment.makeNumeric().\n * The low-level way to create a segment is to custom-make the bit buffer\n * and call the QrSegment() constructor with appropriate values.\n * This segment class imposes no length restrictions, but QR Codes have restrictions.\n * Even in the most favorable conditions, a QR Code can only hold 7089 characters of data.\n * Any segment longer than this is meaningless for the purpose of generating QR Codes.\n */\nexport class QrSegment {\n  /* -- Static factory functions (mid level) --*/\n\n  // Returns a segment representing the given binary data encoded in\n  // byte mode. All input byte arrays are acceptable. Any text string\n  // can be converted to UTF-8 bytes and encoded as a byte mode segment.\n  public static makeBytes(data: Readonly<number[]>): QrSegment {\n    const bb: number[] = [];\n    for (const b of data) {\n      appendBits(b, 8, bb);\n    }\n    return new QrSegment(Mode.BYTE, data.length, bb);\n  }\n\n  // Returns a segment representing the given string of decimal digits encoded in numeric mode.\n  public static makeNumeric(digits: string): QrSegment {\n    if (!QrSegment.isNumeric(digits)) {\n      throw new RangeError(\"String contains non-numeric characters\");\n    }\n    const bb: number[] = [];\n    for (let i = 0; i < digits.length; ) {\n      // Consume up to 3 digits per iteration\n      const n: number = Math.min(digits.length - i, 3);\n      appendBits(parseInt(digits.substring(i, i + n), 10), n * 3 + 1, bb);\n      i += n;\n    }\n    return new QrSegment(Mode.NUMERIC, digits.length, bb);\n  }\n\n  // Returns a segment representing the given text string encoded in alphanumeric mode.\n  // The characters allowed are: 0 to 9, A to Z (uppercase only), space,\n  // dollar, percent, asterisk, plus, hyphen, period, slash, colon.\n  public static makeAlphanumeric(text: string): QrSegment {\n    if (!QrSegment.isAlphanumeric(text)) {\n      throw new RangeError(\n        \"String contains unencodable characters in alphanumeric mode\"\n      );\n    }\n    const bb: number[] = [];\n    let i: number;\n    for (i = 0; i + 2 <= text.length; i += 2) {\n      // Process groups of 2\n      let temp: number =\n        QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)) * 45;\n      temp += QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i + 1));\n      appendBits(temp, 11, bb);\n    }\n    if (i < text.length) {\n      // 1 character remaining\n      appendBits(QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)), 6, bb);\n    }\n    return new QrSegment(Mode.ALPHANUMERIC, text.length, bb);\n  }\n\n  // Returns a new mutable list of zero or more segments to represent the given Unicode text string.\n  // The result may use various segment modes and switch modes to optimize the length of the bit stream.\n  public static makeSegments(text: string): QrSegment[] {\n    // Select the most efficient segment encoding automatically\n    if (text === \"\") {\n      return [];\n    }\n    if (QrSegment.isNumeric(text)) {\n      return [QrSegment.makeNumeric(text)];\n    }\n    if (QrSegment.isAlphanumeric(text)) {\n      return [QrSegment.makeAlphanumeric(text)];\n    }\n    return [QrSegment.makeBytes(QrSegment.toUtf8ByteArray(text))];\n  }\n\n  // Returns a segment representing an Extended Channel Interpretation\n  // (ECI) designator with the given assignment value.\n  public static makeEci(assignVal: number): QrSegment {\n    const bb: number[] = [];\n    if (assignVal < 0) {\n      throw new RangeError(\"ECI assignment value out of range\");\n    } else if (assignVal < 1 << 7) {\n      appendBits(assignVal, 8, bb);\n    } else if (assignVal < 1 << 14) {\n      appendBits(0b10, 2, bb);\n      appendBits(assignVal, 14, bb);\n    } else if (assignVal < 1000000) {\n      appendBits(0b110, 3, bb);\n      appendBits(assignVal, 21, bb);\n    } else {\n      throw new RangeError(\"ECI assignment value out of range\");\n    }\n    return new QrSegment(Mode.ECI, 0, bb);\n  }\n\n  // Tests whether the given string can be encoded as a segment in numeric mode.\n  // A string is encodable iff each character is in the range 0 to 9.\n  public static isNumeric(text: string): boolean {\n    return QrSegment.NUMERIC_REGEX.test(text);\n  }\n\n  // Tests whether the given string can be encoded as a segment in alphanumeric mode.\n  // A string is encodable iff each character is in the following set: 0 to 9, A to Z\n  // (uppercase only), space, dollar, percent, asterisk, plus, hyphen, period, slash, colon.\n  public static isAlphanumeric(text: string): boolean {\n    return QrSegment.ALPHANUMERIC_REGEX.test(text);\n  }\n\n  /* -- Constructor (low level) and fields --*/\n  // The mode indicator of this segment.\n  public mode: Mode;\n\n  // The length of this segment's unencoded data. Measured in characters for\n  // numeric/alphanumeric/kanji mode, bytes for byte mode, and 0 for ECI mode.\n  // Always zero or positive. Not the same as the data's bit length.\n  public numChars: number;\n\n  // The data bits of this segment. Accessed through getData().\n  private bitData: number[];\n\n  // Creates a new QR Code segment with the given attributes and data.\n  // The character count (numChars) must agree with the mode and the bit buffer length,\n  // but the constranumber isn't checked. The given bit buffer is cloned and stored.\n  public constructor(mode: Mode, numChars: number, bitData: number[]) {\n    this.mode = mode;\n    this.numChars = numChars;\n    this.bitData = bitData;\n    if (numChars < 0) {\n      throw new RangeError(\"Invalid argument\");\n    }\n    this.bitData = bitData.slice(); // Make defensive copy\n  }\n\n  /* -- Methods --*/\n\n  // Returns a new copy of the data bits of this segment.\n  public getData(): number[] {\n    return this.bitData.slice(); // Make defensive copy\n  }\n\n  // (Package-private) Calculates and returns the number of bits needed to encode the given segments at\n  // the given version. The result is infinity if a segment has too many characters to fit its length field.\n  public static getTotalBits(\n    segs: Readonly<QrSegment[]>,\n    version: number\n  ): number {\n    let result: number = 0;\n    for (const seg of segs) {\n      const ccbits: number = seg.mode.numCharCountBits(version);\n      if (seg.numChars >= 1 << ccbits) {\n        return Infinity; // The segment's length doesn't fit the field's bit width\n      }\n      result += 4 + ccbits + seg.bitData.length;\n    }\n    return result;\n  }\n\n  // Returns a new array of bytes representing the given string encoded in UTF-8.\n  private static toUtf8ByteArray(input: string): number[] {\n    const str = encodeURI(input);\n    const result: number[] = [];\n    for (let i = 0; i < str.length; i++) {\n      if (str.charAt(i) !== \"%\") {\n        result.push(str.charCodeAt(i));\n      } else {\n        result.push(parseInt(str.substring(i + 1, i + 3), 16));\n        i += 2;\n      }\n    }\n    return result;\n  }\n\n  /* -- Constants --*/\n\n  // Describes precisely all strings that are encodable in numeric mode.\n  private static readonly NUMERIC_REGEX: RegExp = /^[0-9]*$/;\n\n  // Describes precisely all strings that are encodable in alphanumeric mode.\n  private static readonly ALPHANUMERIC_REGEX: RegExp = /^[A-Z0-9 $%*+.\\/:-]*$/;\n\n  // The set of all legal characters in alphanumeric mode,\n  // where each character value maps to the index in the string.\n  private static readonly ALPHANUMERIC_CHARSET: string =\n    \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:\";\n}\n\n/*\n * A QR Code symbol, which is a type of two-dimension barcode.\n * Invented by Denso Wave and described in the ISO/IEC 18004 standard.\n * Instances of this class represent an immutable square grid of dark and light cells.\n * The class provides static factory functions to create a QR Code from text or binary data.\n * The class covers the QR Code Model 2 specification, supporting all versions (sizes)\n * from 1 to 40, all 4 error correction levels, and 4 character encoding modes.\n *\n * Ways to create a QR Code object:\n * - High level: Take the payload data and call QrCode.encodeText() or QrCode.encodeBinary().\n * - Mid level: Custom-make the list of segments and call QrCode.encodeSegments().\n * - Low level: Custom-make the array of data codeword bytes (including\n *   segment headers and final padding, excluding error correction codewords),\n *   supply the appropriate version number, and call the QrCode() constructor.\n * (Note that all ways require supplying the desired error correction level.)\n */\nexport class QrCode {\n  /* -- Static factory functions (high level) --*/\n\n  // Returns a QR Code representing the given Unicode text string at the given error correction level.\n  // As a conservative upper bound, this function is guaranteed to succeed for strings that have 738 or fewer\n  // Unicode code ponumbers (not UTF-16 code units) if the low error correction level is used. The smallest possible\n  // QR Code version is automatically chosen for the output. The ECC level of the result may be higher than the\n  // ecl argument if it can be done without increasing the version.\n  public static encodeText(text: string, ecl: Ecc): QrCode {\n    const segs: QrSegment[] = QrSegment.makeSegments(text);\n    return QrCode.encodeSegments(segs, ecl);\n  }\n\n  // Returns a QR Code representing the given binary data at the given error correction level.\n  // This function always encodes using the binary segment mode, not any text mode. The maximum number of\n  // bytes allowed is 2953. The smallest possible QR Code version is automatically chosen for the output.\n  // The ECC level of the result may be higher than the ecl argument if it can be done without increasing the version.\n  public static encodeBinary(data: Readonly<number[]>, ecl: Ecc): QrCode {\n    const seg = QrSegment.makeBytes(data);\n    return QrCode.encodeSegments([seg], ecl);\n  }\n\n  /* -- Static factory functions (mid level) --*/\n\n  // Returns a QR Code representing the given segments with the given encoding parameters.\n  // The smallest possible QR Code version within the given range is automatically\n  // chosen for the output. Iff boostEcl is true, then the ECC level of the result\n  // may be higher than the ecl argument if it can be done without increasing the\n  // version. The mask number is either between 0 to 7 (inclusive) to force that\n  // mask, or -1 to automatically choose an appropriate mask (which may be slow).\n  // This function allows the user to create a custom sequence of segments that switches\n  // between modes (such as alphanumeric and byte) to encode text in less space.\n  // This is a mid-level API; the high-level API is encodeText() and encodeBinary().\n  public static encodeSegments(\n    segs: Readonly<QrSegment[]>,\n    oriEcl: Ecc,\n    minVersion: number = 1,\n    maxVersion: number = 40,\n    mask: number = -1,\n    boostEcl: boolean = true\n  ): QrCode {\n    if (\n      !(\n        QrCode.MIN_VERSION <= minVersion &&\n        minVersion <= maxVersion &&\n        maxVersion <= QrCode.MAX_VERSION\n      ) ||\n      mask < -1 ||\n      mask > 7\n    ) {\n      throw new RangeError(\"Invalid value\");\n    }\n\n    // Find the minimal version number to use\n    let version: number;\n    let dataUsedBits: number;\n    for (version = minVersion; ; version++) {\n      const dataCapacityBits = QrCode.getNumDataCodewords(version, oriEcl) * 8; // Number of data bits available\n      const usedBits: number = QrSegment.getTotalBits(segs, version);\n      if (usedBits <= dataCapacityBits) {\n        dataUsedBits = usedBits;\n        break; // This version number is found to be suitable\n      }\n      if (version >= maxVersion) {\n        // All versions in the range could not fit the given data\n        throw new RangeError(\"Data too long\");\n      }\n    }\n    let ecl: Ecc = oriEcl;\n    // Increase the error correction level while the data still fits in the current version number\n    for (const newEcl of [Ecc.MEDIUM, Ecc.QUARTILE, Ecc.HIGH]) {\n      // From low to high\n      if (\n        boostEcl &&\n        dataUsedBits <= QrCode.getNumDataCodewords(version, newEcl) * 8\n      ) {\n        ecl = newEcl;\n      }\n    }\n\n    // Concatenate all segments to create the data bit string\n    const bb: number[] = [];\n    for (const seg of segs) {\n      appendBits(seg.mode.modeBits, 4, bb);\n      appendBits(seg.numChars, seg.mode.numCharCountBits(version), bb);\n      for (const b of seg.getData()) {\n        bb.push(b);\n      }\n    }\n    assert(bb.length === dataUsedBits);\n\n    // Add terminator and pad up to a byte if applicable\n    const dataCapacityBits = QrCode.getNumDataCodewords(version, ecl) * 8;\n    assert(bb.length <= dataCapacityBits);\n    appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);\n    appendBits(0, (8 - (bb.length % 8)) % 8, bb);\n    assert(bb.length % 8 === 0);\n\n    // Pad with alternating bytes until data capacity is reached\n    for (\n      let padByte = 0xec;\n      bb.length < dataCapacityBits;\n      padByte ^= 0xec ^ 0x11\n    ) {\n      appendBits(padByte, 8, bb);\n    }\n\n    // Pack bits numbero bytes in big endian\n    const dataCodewords: number[] = [];\n    while (dataCodewords.length * 8 < bb.length) {\n      dataCodewords.push(0);\n    }\n    bb.forEach((b, i) => {\n      dataCodewords[i >>> 3] |= b << (7 - (i & 7));\n    });\n\n    // Create the QR Code object\n    return new QrCode(version, ecl, dataCodewords, mask);\n  }\n\n  /* -- Fields --*/\n\n  // The width and height of this QR Code, measured in modules, between\n  // 21 and 177 (inclusive). This is equal to version * 4 + 17.\n  public readonly size: number;\n\n  // The index of the mask pattern used in this QR Code, which is between 0 and 7 (inclusive).\n  // Even if a QR Code is created with automatic masking requested (mask = -1),\n  // the resulting object still has a mask value between 0 and 7.\n  public readonly mask: number;\n\n  // The modules of this QR Code (false = light, true = dark).\n  // Immutable after constructor finishes. Accessed through getModule().\n  private readonly modules: boolean[][] = [];\n\n  // Indicates function modules that are not subjected to masking. Discarded when constructor finishes.\n  private readonly isFunction: boolean[][] = [];\n\n  /* -- Constructor (low level) and fields --*/\n  // The version number of this QR Code, which is between 1 and 40 (inclusive).\n  // This determines the size of this barcode.\n  public version: number;\n\n  // The error correction level used in this QR Code.\n  public errorCorrectionLevel: Ecc;\n\n  // Creates a new QR Code with the given version number,\n  // error correction level, data codeword bytes, and mask number.\n  // This is a low-level API that most users should not use directly.\n  // A mid-level API is the encodeSegments() function.\n  public constructor(\n    // The version number of this QR Code, which is between 1 and 40 (inclusive).\n    // This determines the size of this barcode.\n    version: number,\n\n    // The error correction level used in this QR Code.\n    errorCorrectionLevel: Ecc,\n\n    dataCodewords: Readonly<number[]>,\n\n    oriMsk: number\n  ) {\n    let msk = oriMsk;\n    this.version = version;\n    this.errorCorrectionLevel = errorCorrectionLevel;\n    // Check scalar arguments\n    if (version < QrCode.MIN_VERSION || version > QrCode.MAX_VERSION) {\n      throw new RangeError(\"Version value out of range\");\n    }\n    if (msk < -1 || msk > 7) {\n      throw new RangeError(\"Mask value out of range\");\n    }\n    this.size = version * 4 + 17;\n\n    // Initialize both grids to be size*size arrays of Boolean false\n    const row: boolean[] = [];\n    for (let i = 0; i < this.size; i++) {\n      row.push(false);\n    }\n    for (let i = 0; i < this.size; i++) {\n      this.modules.push(row.slice()); // Initially all light\n      this.isFunction.push(row.slice());\n    }\n\n    // Compute ECC, draw modules\n    this.drawFunctionPatterns();\n    const allCodewords: number[] = this.addEccAndInterleave(dataCodewords);\n    this.drawCodewords(allCodewords);\n\n    // Do masking\n    if (msk === -1) {\n      // Automatically choose best mask\n      let minPenalty: number = 1000000000;\n      for (let i = 0; i < 8; i++) {\n        this.applyMask(i);\n        this.drawFormatBits(i);\n        const penalty: number = this.getPenaltyScore();\n        if (penalty < minPenalty) {\n          msk = i;\n          minPenalty = penalty;\n        }\n        this.applyMask(i); // Undoes the mask due to XOR\n      }\n    }\n    assert(msk >= 0 && msk <= 7);\n    this.mask = msk;\n    this.applyMask(msk); // Apply the final choice of mask\n    this.drawFormatBits(msk); // Overwrite old format bits\n\n    this.isFunction = [];\n  }\n\n  /* -- Accessor methods --*/\n\n  // Returns the color of the module (pixel) at the given coordinates, which is false\n  // for light or true for dark. The top left corner has the coordinates (x=0, y=0).\n  // If the given coordinates are out of bounds, then false (light) is returned.\n  public getModule(x: number, y: number): boolean {\n    return (\n      x >= 0 && x < this.size && y >= 0 && y < this.size && this.modules[y][x]\n    );\n  }\n\n  // Modified to expose modules for easy access\n  public getModules() {\n    return this.modules;\n  }\n\n  /* -- Private helper methods for constructor: Drawing function modules --*/\n\n  // Reads this object's version field, and draws and marks all function modules.\n  private drawFunctionPatterns(): void {\n    // Draw horizontal and vertical timing patterns\n    for (let i = 0; i < this.size; i++) {\n      this.setFunctionModule(6, i, i % 2 === 0);\n      this.setFunctionModule(i, 6, i % 2 === 0);\n    }\n\n    // Draw 3 finder patterns (all corners except bottom right; overwrites some timing modules)\n    this.drawFinderPattern(3, 3);\n    this.drawFinderPattern(this.size - 4, 3);\n    this.drawFinderPattern(3, this.size - 4);\n\n    // Draw numerous alignment patterns\n    const alignPatPos: number[] = this.getAlignmentPatternPositions();\n    const numAlign: number = alignPatPos.length;\n    for (let i = 0; i < numAlign; i++) {\n      for (let j = 0; j < numAlign; j++) {\n        // Don't draw on the three finder corners\n        if (\n          !(\n            (i === 0 && j === 0) ||\n            (i === 0 && j === numAlign - 1) ||\n            (i === numAlign - 1 && j === 0)\n          )\n        ) {\n          this.drawAlignmentPattern(alignPatPos[i], alignPatPos[j]);\n        }\n      }\n    }\n\n    // Draw configuration data\n    this.drawFormatBits(0); // Dummy mask value; overwritten later in the constructor\n    this.drawVersion();\n  }\n\n  // Draws two copies of the format bits (with its own error correction code)\n  // based on the given mask and this object's error correction level field.\n  private drawFormatBits(mask: number): void {\n    // Calculate error correction code and pack bits\n    const data: number = (this.errorCorrectionLevel.formatBits << 3) | mask; // errCorrLvl is unumber2, mask is unumber3\n    let rem: number = data;\n    for (let i = 0; i < 10; i++) {\n      rem = (rem << 1) ^ ((rem >>> 9) * 0x537);\n    }\n    const bits = ((data << 10) | rem) ^ 0x5412; // unumber15\n    assert(bits >>> 15 === 0);\n\n    // Draw first copy\n    for (let i = 0; i <= 5; i++) {\n      this.setFunctionModule(8, i, getBit(bits, i));\n    }\n    this.setFunctionModule(8, 7, getBit(bits, 6));\n    this.setFunctionModule(8, 8, getBit(bits, 7));\n    this.setFunctionModule(7, 8, getBit(bits, 8));\n    for (let i = 9; i < 15; i++) {\n      this.setFunctionModule(14 - i, 8, getBit(bits, i));\n    }\n    // Draw second copy\n    for (let i = 0; i < 8; i++) {\n      this.setFunctionModule(this.size - 1 - i, 8, getBit(bits, i));\n    }\n    for (let i = 8; i < 15; i++) {\n      this.setFunctionModule(8, this.size - 15 + i, getBit(bits, i));\n    }\n    this.setFunctionModule(8, this.size - 8, true); // Always dark\n  }\n\n  // Draws two copies of the version bits (with its own error correction code),\n  // based on this object's version field, iff 7 <= version <= 40.\n  private drawVersion(): void {\n    if (this.version < 7) {\n      return;\n    }\n\n    // Calculate error correction code and pack bits\n    let rem: number = this.version; // version is unumber6, in the range [7, 40]\n    for (let i = 0; i < 12; i++) {\n      rem = (rem << 1) ^ ((rem >>> 11) * 0x1f25);\n    }\n    const bits: number = (this.version << 12) | rem; // unumber18\n    assert(bits >>> 18 === 0);\n\n    // Draw two copies\n    for (let i = 0; i < 18; i++) {\n      const color: boolean = getBit(bits, i);\n      const a: number = this.size - 11 + (i % 3);\n      const b: number = Math.floor(i / 3);\n      this.setFunctionModule(a, b, color);\n      this.setFunctionModule(b, a, color);\n    }\n  }\n\n  // Draws a 9*9 finder pattern including the border separator,\n  // with the center module at (x, y). Modules can be out of bounds.\n  private drawFinderPattern(x: number, y: number): void {\n    for (let dy = -4; dy <= 4; dy++) {\n      for (let dx = -4; dx <= 4; dx++) {\n        const dist: number = Math.max(Math.abs(dx), Math.abs(dy)); // Chebyshev/infinity norm\n        const xx: number = x + dx;\n        const yy: number = y + dy;\n        if (xx >= 0 && xx < this.size && yy >= 0 && yy < this.size) {\n          this.setFunctionModule(xx, yy, dist !== 2 && dist !== 4);\n        }\n      }\n    }\n  }\n\n  // Draws a 5*5 alignment pattern, with the center module\n  // at (x, y). All modules must be in bounds.\n  private drawAlignmentPattern(x: number, y: number): void {\n    for (let dy = -2; dy <= 2; dy++) {\n      for (let dx = -2; dx <= 2; dx++) {\n        this.setFunctionModule(\n          x + dx,\n          y + dy,\n          Math.max(Math.abs(dx), Math.abs(dy)) !== 1\n        );\n      }\n    }\n  }\n\n  // Sets the color of a module and marks it as a function module.\n  // Only used by the constructor. Coordinates must be in bounds.\n  private setFunctionModule(x: number, y: number, isDark: boolean): void {\n    this.modules[y][x] = isDark;\n    this.isFunction[y][x] = true;\n  }\n\n  /* -- Private helper methods for constructor: Codewords and masking --*/\n\n  // Returns a new byte string representing the given data with the appropriate error correction\n  // codewords appended to it, based on this object's version and error correction level.\n  private addEccAndInterleave(data: Readonly<number[]>): number[] {\n    const ver: number = this.version;\n    const ecl: Ecc = this.errorCorrectionLevel;\n    if (data.length !== QrCode.getNumDataCodewords(ver, ecl)) {\n      throw new RangeError(\"Invalid argument\");\n    }\n    // Calculate parameter numbers\n    const numBlocks = QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];\n    const blockEccLen = QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver];\n    const rawCodewords = Math.floor(QrCode.getNumRawDataModules(ver) / 8);\n    const numShortBlocks = numBlocks - (rawCodewords % numBlocks);\n    const shortBlockLen = Math.floor(rawCodewords / numBlocks);\n\n    // Split data numbero blocks and append ECC to each block\n    const blocks: number[][] = [];\n    const rsDiv = QrCode.reedSolomonComputeDivisor(blockEccLen);\n    for (let i = 0, k = 0; i < numBlocks; i++) {\n      const dat = data.slice(\n        k,\n        k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1)\n      );\n      k += dat.length;\n      const ecc: number[] = QrCode.reedSolomonComputeRemainder(dat, rsDiv);\n      if (i < numShortBlocks) {\n        dat.push(0);\n      }\n      blocks.push(dat.concat(ecc));\n    }\n\n    // Interleave (not concatenate) the bytes from every block numbero a single sequence\n    const result: number[] = [];\n    for (let i = 0; i < blocks[0].length; i++) {\n      blocks.forEach((block, j) => {\n        // Skip the padding byte in short blocks\n        if (i !== shortBlockLen - blockEccLen || j >= numShortBlocks) {\n          result.push(block[i]);\n        }\n      });\n    }\n    assert(result.length === rawCodewords);\n    return result;\n  }\n\n  // Draws the given sequence of 8-bit codewords (data and error correction) onto the entire\n  // data area of this QR Code. Function modules need to be marked off before this is called.\n  private drawCodewords(data: Readonly<number[]>): void {\n    if (\n      data.length !== Math.floor(QrCode.getNumRawDataModules(this.version) / 8)\n    ) {\n      throw new RangeError(\"Invalid argument\");\n    }\n    let i: number = 0; // Bit index numbero the data\n    // Do the funny zigzag scan\n    for (let right = this.size - 1; right >= 1; right -= 2) {\n      // Index of right column in each column pair\n      if (right === 6) {\n        right = 5;\n      }\n      for (let vert = 0; vert < this.size; vert++) {\n        // Vertical counter\n        for (let j = 0; j < 2; j++) {\n          const x: number = right - j; // Actual x coordinate\n          const upward: boolean = ((right + 1) & 2) === 0;\n          const y: number = upward ? this.size - 1 - vert : vert; // Actual y coordinate\n          if (!this.isFunction[y][x] && i < data.length * 8) {\n            this.modules[y][x] = getBit(data[i >>> 3], 7 - (i & 7));\n            i++;\n          }\n          // If this QR Code has any remainder bits (0 to 7), they were assigned as\n          // 0/false/light by the constructor and are left unchanged by this method\n        }\n      }\n    }\n    assert(i === data.length * 8);\n  }\n\n  // XORs the codeword modules in this QR Code with the given mask pattern.\n  // The function modules must be marked and the codeword bits must be drawn\n  // before masking. Due to the arithmetic of XOR, calling applyMask() with\n  // the same mask value a second time will undo the mask. A final well-formed\n  // QR Code needs exactly one (not zero, two, etc.) mask applied.\n  private applyMask(mask: number): void {\n    if (mask < 0 || mask > 7) {\n      throw new RangeError(\"Mask value out of range\");\n    }\n    for (let y = 0; y < this.size; y++) {\n      for (let x = 0; x < this.size; x++) {\n        let invert: boolean;\n        switch (mask) {\n          case 0:\n            invert = (x + y) % 2 === 0;\n            break;\n          case 1:\n            invert = y % 2 === 0;\n            break;\n          case 2:\n            invert = x % 3 === 0;\n            break;\n          case 3:\n            invert = (x + y) % 3 === 0;\n            break;\n          case 4:\n            invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 === 0;\n            break;\n          case 5:\n            invert = ((x * y) % 2) + ((x * y) % 3) === 0;\n            break;\n          case 6:\n            invert = (((x * y) % 2) + ((x * y) % 3)) % 2 === 0;\n            break;\n          case 7:\n            invert = (((x + y) % 2) + ((x * y) % 3)) % 2 === 0;\n            break;\n          default:\n            throw new Error(\"Unreachable\");\n        }\n        if (!this.isFunction[y][x] && invert) {\n          this.modules[y][x] = !this.modules[y][x];\n        }\n      }\n    }\n  }\n\n  // Calculates and returns the penalty score based on state of this QR Code's current modules.\n  // This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.\n  private getPenaltyScore(): number {\n    let result: number = 0;\n\n    // Adjacent modules in row having same color, and finder-like patterns\n    for (let y = 0; y < this.size; y++) {\n      let runColor = false;\n      let runX = 0;\n      const runHistory = [0, 0, 0, 0, 0, 0, 0];\n      for (let x = 0; x < this.size; x++) {\n        if (this.modules[y][x] === runColor) {\n          runX++;\n          if (runX === 5) {\n            result += QrCode.PENALTY_N1;\n          } else if (runX > 5) {\n            result++;\n          }\n        } else {\n          this.finderPenaltyAddHistory(runX, runHistory);\n          if (!runColor) {\n            result +=\n              this.finderPenaltyCountPatterns(runHistory) * QrCode.PENALTY_N3;\n          }\n          runColor = this.modules[y][x];\n          runX = 1;\n        }\n      }\n      result +=\n        this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) *\n        QrCode.PENALTY_N3;\n    }\n    // Adjacent modules in column having same color, and finder-like patterns\n    for (let x = 0; x < this.size; x++) {\n      let runColor = false;\n      let runY = 0;\n      const runHistory = [0, 0, 0, 0, 0, 0, 0];\n      for (let y = 0; y < this.size; y++) {\n        if (this.modules[y][x] === runColor) {\n          runY++;\n          if (runY === 5) {\n            result += QrCode.PENALTY_N1;\n          } else if (runY > 5) {\n            result++;\n          }\n        } else {\n          this.finderPenaltyAddHistory(runY, runHistory);\n          if (!runColor) {\n            result +=\n              this.finderPenaltyCountPatterns(runHistory) * QrCode.PENALTY_N3;\n          }\n          runColor = this.modules[y][x];\n          runY = 1;\n        }\n      }\n      result +=\n        this.finderPenaltyTerminateAndCount(runColor, runY, runHistory) *\n        QrCode.PENALTY_N3;\n    }\n\n    // 2*2 blocks of modules having same color\n    for (let y = 0; y < this.size - 1; y++) {\n      for (let x = 0; x < this.size - 1; x++) {\n        const color: boolean = this.modules[y][x];\n        if (\n          color === this.modules[y][x + 1] &&\n          color === this.modules[y + 1][x] &&\n          color === this.modules[y + 1][x + 1]\n        ) {\n          result += QrCode.PENALTY_N2;\n        }\n      }\n    }\n\n    // Balance of dark and light modules\n    let dark: number = 0;\n    for (const row of this.modules) {\n      dark = row.reduce((sum, color) => sum + (color ? 1 : 0), dark);\n    }\n    const total: number = this.size * this.size; // Note that size is odd, so dark/total !== 1/2\n    // Compute the smallest numbereger k >= 0 such that (45-5k)% <= dark/total <= (55+5k)%\n    const k: number = Math.ceil(Math.abs(dark * 20 - total * 10) / total) - 1;\n    assert(k >= 0 && k <= 9);\n    result += k * QrCode.PENALTY_N4;\n    assert(result >= 0 && result <= 2568888); // Non-tight upper bound based on default values of PENALTY_N1, ..., N4\n    return result;\n  }\n\n  /* -- Private helper functions --*/\n\n  // Returns an ascending list of positions of alignment patterns for this version number.\n  // Each position is in the range [0,177), and are used on both the x and y axes.\n  // This could be implemented as lookup table of 40 variable-length lists of numberegers.\n  private getAlignmentPatternPositions(): number[] {\n    if (this.version === 1) {\n      return [];\n    }\n    const numAlign = Math.floor(this.version / 7) + 2;\n    const step =\n      this.version === 32\n        ? 26\n        : Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2;\n    const result: number[] = [6];\n    for (let pos = this.size - 7; result.length < numAlign; pos -= step) {\n      result.splice(1, 0, pos);\n    }\n    return result;\n  }\n\n  // Returns the number of data bits that can be stored in a QR Code of the given version number, after\n  // all function modules are excluded. This includes remainder bits, so it might not be a multiple of 8.\n  // The result is in the range [208, 29648]. This could be implemented as a 40-entry lookup table.\n  private static getNumRawDataModules(ver: number): number {\n    if (ver < QrCode.MIN_VERSION || ver > QrCode.MAX_VERSION) {\n      throw new RangeError(\"Version number out of range\");\n    }\n    let result: number = (16 * ver + 128) * ver + 64;\n    if (ver >= 2) {\n      const numAlign: number = Math.floor(ver / 7) + 2;\n      result -= (25 * numAlign - 10) * numAlign - 55;\n      if (ver >= 7) {\n        result -= 36;\n      }\n    }\n    assert(result >= 208 && result <= 29648);\n    return result;\n  }\n\n  // Returns the number of 8-bit data (i.e. not error correction) codewords contained in any\n  // QR Code of the given version number and error correction level, with remainder bits discarded.\n  // This stateless pure function could be implemented as a (40*4)-cell lookup table.\n  private static getNumDataCodewords(ver: number, ecl: Ecc): number {\n    return (\n      Math.floor(QrCode.getNumRawDataModules(ver) / 8) -\n      QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver] *\n        QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver]\n    );\n  }\n\n  // Returns a Reed-Solomon ECC generator polynomial for the given degree. This could be\n  // implemented as a lookup table over all possible parameter values, instead of as an algorithm.\n  private static reedSolomonComputeDivisor(degree: number): number[] {\n    if (degree < 1 || degree > 255) {\n      throw new RangeError(\"Degree out of range\");\n    }\n    // Polynomial coefficients are stored from highest to lowest power, excluding the leading term which is always 1.\n    // For example the polynomial x^3 + 255x^2 + 8x + 93 is stored as the unumber8 array [255, 8, 93].\n    const result: number[] = [];\n    for (let i = 0; i < degree - 1; i++) {\n      result.push(0);\n    }\n    result.push(1); // Start off with the monomial x^0\n\n    // Compute the product polynomial (x - r^0) * (x - r^1) * (x - r^2) * ... * (x - r^{degree-1}),\n    // and drop the highest monomial term which is always 1x^degree.\n    // Note that r = 0x02, which is a generator element of this field GF(2^8/0x11D).\n    let root = 1;\n    for (let i = 0; i < degree; i++) {\n      // Multiply the current product by (x - r^i)\n      for (let j = 0; j < result.length; j++) {\n        result[j] = QrCode.reedSolomonMultiply(result[j], root);\n        if (j + 1 < result.length) {\n          result[j] ^= result[j + 1];\n        }\n      }\n      root = QrCode.reedSolomonMultiply(root, 0x02);\n    }\n    return result;\n  }\n\n  // Returns the Reed-Solomon error correction codeword for the given data and divisor polynomials.\n  private static reedSolomonComputeRemainder(\n    data: Readonly<number[]>,\n    divisor: Readonly<number[]>\n  ) {\n    const result = divisor.map<number>(() => 0);\n    for (const b of data) {\n      // Polynomial division\n      const factor = b ^ result.shift();\n      result.push(0);\n      divisor.forEach((coef, i) => {\n        result[i] ^= QrCode.reedSolomonMultiply(coef, factor);\n      });\n    }\n    return result;\n  }\n\n  // Returns the product of the two given field elements modulo GF(2^8/0x11D). The arguments and result\n  // are unsigned 8-bit numberegers. This could be implemented as a lookup table of 256*256 entries of unumber8.\n  private static reedSolomonMultiply(x: number, y: number): number {\n    if (x >>> 8 !== 0 || y >>> 8 !== 0) {\n      throw new RangeError(\"Byte out of range\");\n    }\n    // Russian peasant multiplication\n    let z: number = 0;\n    for (let i = 7; i >= 0; i--) {\n      z = (z << 1) ^ ((z >>> 7) * 0x11d);\n      z ^= ((y >>> i) & 1) * x;\n    }\n    assert(z >>> 8 === 0);\n    return z as number;\n  }\n\n  // Can only be called immediately after a light run is added, and\n  // returns either 0, 1, or 2. A helper function for getPenaltyScore().\n  private finderPenaltyCountPatterns(runHistory: Readonly<number[]>): number {\n    const n: number = runHistory[1];\n    assert(n <= this.size * 3);\n    const core: boolean =\n      n > 0 &&\n      runHistory[2] === n &&\n      runHistory[3] === n * 3 &&\n      runHistory[4] === n &&\n      runHistory[5] === n;\n    return (\n      (core && runHistory[0] >= n * 4 && runHistory[6] >= n ? 1 : 0) +\n      (core && runHistory[6] >= n * 4 && runHistory[0] >= n ? 1 : 0)\n    );\n  }\n\n  // Must be called at the end of a line (row or column) of modules. A helper function for getPenaltyScore().\n  private finderPenaltyTerminateAndCount(\n    currentRunColor: boolean,\n    oriCurrentRunLength: number,\n    runHistory: number[]\n  ): number {\n    let currentRunLength = oriCurrentRunLength;\n    if (currentRunColor) {\n      // Terminate dark run\n      this.finderPenaltyAddHistory(currentRunLength, runHistory);\n      currentRunLength = 0;\n    }\n    currentRunLength += this.size; // Add light border to final run\n    this.finderPenaltyAddHistory(currentRunLength, runHistory);\n    return this.finderPenaltyCountPatterns(runHistory);\n  }\n\n  // Pushes the given value to the front and drops the last value. A helper function for getPenaltyScore().\n  private finderPenaltyAddHistory(\n    oriCurrentRunLength: number,\n    runHistory: number[]\n  ) {\n    let currentRunLength = oriCurrentRunLength;\n    if (runHistory[0] === 0) {\n      currentRunLength += this.size; // Add light border to initial run\n    }\n    runHistory.pop();\n    runHistory.unshift(currentRunLength);\n  }\n\n  /* -- Constants and tables --*/\n\n  // The minimum version number supported in the QR Code Model 2 standard.\n  public static readonly MIN_VERSION: number = 1;\n\n  // The maximum version number supported in the QR Code Model 2 standard.\n  public static readonly MAX_VERSION: number = 40;\n\n  // For use in getPenaltyScore(), when evaluating which mask is best.\n  private static readonly PENALTY_N1: number = 3;\n\n  private static readonly PENALTY_N2: number = 3;\n\n  private static readonly PENALTY_N3: number = 40;\n\n  private static readonly PENALTY_N4: number = 10;\n\n  private static readonly ECC_CODEWORDS_PER_BLOCK: number[][] = [\n    // Version: (note that index 0 is for padding, and is set to an illegal value)\n    // 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level\n    [\n      -1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30,\n      28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n      30, 30, 30, 30,\n    ], // Low\n    [\n      -1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28,\n      26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n      28, 28, 28, 28, 28,\n    ], // Medium\n    [\n      -1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28,\n      28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n      30, 30, 30, 30, 30,\n    ], // Quartile\n    [\n      -1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28,\n      28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n      30, 30, 30, 30, 30,\n    ], // High\n  ];\n\n  private static readonly NUM_ERROR_CORRECTION_BLOCKS: number[][] = [\n    // Version: (note that index 0 is for padding, and is set to an illegal value)\n    // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level\n    [\n      -1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9,\n      10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25,\n    ], // Low\n    [\n      -1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17,\n      17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47,\n      49,\n    ], // Medium\n    [\n      -1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20,\n      23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62,\n      65, 68,\n    ], // Quartile\n    [\n      -1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25,\n      25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74,\n      77, 81,\n    ], // High\n  ];\n}\n","import type {\n  CrossOrigin,\n  ERROR_LEVEL_MAPPED_TYPE,\n  ErrorCorrectionLevel,\n  Excavation,\n  ImageSettings,\n  Modules,\n} from './types';\nimport { Ecc } from './qrcodegen';\n\n// =================== ERROR_LEVEL ==========================\nexport const ERROR_LEVEL_MAP: ERROR_LEVEL_MAPPED_TYPE = {\n  L: Ecc.LOW,\n  M: Ecc.MEDIUM,\n  Q: Ecc.QUARTILE,\n  H: Ecc.HIGH,\n} as const;\n\n// =================== DEFAULT_VALUE ==========================\nexport const DEFAULT_SIZE = 160;\nexport const DEFAULT_LEVEL: ErrorCorrectionLevel = 'M';\nexport const DEFAULT_BACKGROUND_COLOR = '#FFFFFF';\nexport const DEFAULT_FRONT_COLOR = '#000000';\nexport const DEFAULT_NEED_MARGIN = false;\nexport const DEFAULT_MINVERSION = 1;\nexport const SPEC_MARGIN_SIZE = 4;\nexport const DEFAULT_MARGIN_SIZE = 0;\nexport const DEFAULT_IMG_SCALE = 0.1;\n\n// =================== UTILS ==========================\n/**\n * Generate a path string from modules\n * @param modules\n * @param margin\n * @returns\n */\nexport const generatePath = (modules: Modules, margin: number = 0) => {\n  const ops: string[] = [];\n  modules.forEach((row, y) => {\n    let start: number | null = null;\n    row.forEach((cell, x) => {\n      if (!cell && start !== null) {\n        ops.push(\n          `M${start + margin} ${y + margin}h${x - start}v1H${start + margin}z`\n        );\n        start = null;\n        return;\n      }\n\n      if (x === row.length - 1) {\n        if (!cell) {\n          return;\n        }\n        if (start === null) {\n          ops.push(`M${x + margin},${y + margin} h1v1H${x + margin}z`);\n        } else {\n          ops.push(\n            `M${start + margin},${y + margin} h${x + 1 - start}v1H${\n              start + margin\n            }z`\n          );\n        }\n        return;\n      }\n\n      if (cell && start === null) {\n        start = x;\n      }\n    });\n  });\n  return ops.join('');\n};\n\n/**\n * Excavate modules\n * @param modules\n * @param excavation\n * @returns\n */\nexport const excavateModules = (modules: Modules, excavation: Excavation) => modules.slice().map((row, y) => {\n  if (y < excavation.y || y >= excavation.y + excavation.h) {\n    return row;\n  }\n  return row.map((cell, x) => {\n    if (x < excavation.x || x >= excavation.x + excavation.w) {\n      return cell;\n    }\n    return false;\n  });\n});\n\n/**\n * Get image settings\n * @param cells The modules of the QR code\n * @param size The size of the QR code\n * @param margin\n * @param imageSettings\n * @returns\n */\nexport const getImageSettings = (\n  cells: Modules,\n  size: number,\n  margin: number,\n  imageSettings?: ImageSettings\n): null | {\n  x: number;\n  y: number;\n  h: number;\n  w: number;\n  excavation: Excavation | null;\n  opacity: number;\n  crossOrigin: CrossOrigin;\n} => {\n  if (imageSettings == null) {\n    return null;\n  }\n  const numCells = cells.length + margin * 2;\n  const defaultSize = Math.floor(size * DEFAULT_IMG_SCALE);\n  const scale = numCells / size;\n  const w = (imageSettings.width || defaultSize) * scale;\n  const h = (imageSettings.height || defaultSize) * scale;\n  const x = imageSettings.x == null\n    ? cells.length / 2 - w / 2\n    : imageSettings.x * scale;\n  const y = imageSettings.y == null\n    ? cells.length / 2 - h / 2\n    : imageSettings.y * scale;\n  const opacity = imageSettings.opacity == null ? 1 : imageSettings.opacity;\n\n  let excavation = null;\n  if (imageSettings.excavate) {\n    const floorX = Math.floor(x);\n    const floorY = Math.floor(y);\n    const ceilW = Math.ceil(w + x - floorX);\n    const ceilH = Math.ceil(h + y - floorY);\n    excavation = { x: floorX, y: floorY, w: ceilW, h: ceilH };\n  }\n\n  const { crossOrigin } = imageSettings;\n\n  return { x, y, h, w, excavation, opacity, crossOrigin };\n};\n\n/**\n * Get margin size\n * @param needMargin Whether need margin\n * @param marginSize Custom margin size\n * @returns\n */\nexport const getMarginSize = (needMargin: boolean, marginSize?: number) => {\n  if (marginSize != null) {\n    return Math.max(Math.floor(marginSize), 0);\n  }\n  return needMargin ? SPEC_MARGIN_SIZE : DEFAULT_MARGIN_SIZE;\n};\n\n/**\n * Check if Path2D is supported\n */\nexport const isSupportPath2d = (() => {\n  try {\n    new Path2D().addPath(new Path2D());\n  } catch {\n    return false;\n  }\n  return true;\n})();\n","import { QrCode, QrSegment } from '@tdesign/common-js/qrcode/qrcodegen';\nimport type { CrossOrigin, ErrorCorrectionLevel, Excavation, ImageSettings } from '@tdesign/common-js/qrcode/types';\nimport { ERROR_LEVEL_MAP, getImageSettings, getMarginSize } from '@tdesign/common-js/qrcode/utils';\nimport { computed, ComputedRef } from 'vue';\n\ninterface Options {\n  value: string;\n  level: ErrorCorrectionLevel;\n  minVersion: number;\n  includeMargin: boolean;\n  marginSize?: number;\n  imageSettings?: ImageSettings;\n  size: number;\n}\n\ninterface QRCodeResult {\n  cells: ComputedRef<boolean[][]>;\n  margin: ComputedRef<number>;\n  numCells: ComputedRef<number>;\n  calculatedImageSettings: ComputedRef<{\n    x: number;\n    y: number;\n    h: number;\n    w: number;\n    excavation: Excavation | null;\n    opacity: number;\n    crossOrigin: CrossOrigin;\n  }>;\n  qrcode: ComputedRef<QrCode>;\n}\n\nexport const useQRCode = (opt: Options): QRCodeResult => {\n  const { value, level, minVersion, includeMargin, marginSize, imageSettings, size } = opt;\n\n  const memoizedQrcode = computed(() => {\n    const segments = QrSegment.makeSegments(value);\n    return QrCode.encodeSegments(segments, ERROR_LEVEL_MAP[level], minVersion);\n  });\n\n  const cs = computed(() => memoizedQrcode.value.getModules());\n  const mg = computed(() => getMarginSize(includeMargin, marginSize));\n  const cis = computed(() => getImageSettings(cs.value, size, mg.value, imageSettings));\n\n  return {\n    cells: cs,\n    margin: mg,\n    numCells: computed(() => cs.value.length + mg.value * 2),\n    calculatedImageSettings: cis,\n    qrcode: memoizedQrcode,\n  };\n};\n\nexport default useQRCode;\n"],"names":["appendBits","val","len","bb","RangeError","i","push","getBit","x","assert","cond","Error","Mode","modeBits","numBitsCharCount","_classCallCheck","_defineProperty","_createClass","key","value","numCharCountBits","ver","Math","floor","_Mode","Ecc","ordinal","formatBits","_Ecc","QrSegment","mode","numChars","bitData","slice","getData","makeBytes","data","_iterator","_createForOfIteratorHelper","_step","s","n","done","b","err","e","f","BYTE","length","makeNumeric","digits","isNumeric","min","parseInt","substring","NUMERIC","makeAlphanumeric","text","isAlphanumeric","temp","ALPHANUMERIC_CHARSET","indexOf","charAt","ALPHANUMERIC","makeSegments","toUtf8ByteArray","makeEci","assignVal","ECI","NUMERIC_REGEX","test","ALPHANUMERIC_REGEX","getTotalBits","segs","version","result","_iterator2","_step2","seg","ccbits","Infinity","input","str","encodeURI","charCodeAt","QrCode","errorCorrectionLevel","dataCodewords","oriMsk","msk","MIN_VERSION","MAX_VERSION","size","row","modules","isFunction","drawFunctionPatterns","allCodewords","addEccAndInterleave","drawCodewords","minPenalty","applyMask","drawFormatBits","penalty","getPenaltyScore","mask","getModule","y","getModules","setFunctionModule","drawFinderPattern","alignPatPos","getAlignmentPatternPositions","numAlign","j","drawAlignmentPattern","drawVersion","rem","bits","color","a","dy","dx","dist","max","abs","xx","yy","isDark","ecl","getNumDataCodewords","numBlocks","NUM_ERROR_CORRECTION_BLOCKS","blockEccLen","ECC_CODEWORDS_PER_BLOCK","rawCodewords","getNumRawDataModules","numShortBlocks","shortBlockLen","blocks","rsDiv","reedSolomonComputeDivisor","k","dat","ecc","reedSolomonComputeRemainder","concat","_loop","_i9","forEach","block","right","vert","upward","invert","runColor","runX","runHistory","PENALTY_N1","finderPenaltyAddHistory","finderPenaltyCountPatterns","PENALTY_N3","finderPenaltyTerminateAndCount","runY","PENALTY_N2","dark","_iterator3","_step3","reduce","sum","total","ceil","PENALTY_N4","step","pos","splice","core","currentRunColor","oriCurrentRunLength","currentRunLength","pop","unshift","encodeText","encodeSegments","encodeBinary","oriEcl","minVersion","arguments","undefined","maxVersion","boostEcl","dataUsedBits","dataCapacityBits","usedBits","_i0","_arr","MEDIUM","QUARTILE","HIGH","newEcl","_iterator4","_step4","_iterator5","_step5","padByte","degree","root","reedSolomonMultiply","divisor","map","_iterator6","_step6","_loop2","factor","shift","coef","z","ERROR_LEVEL_MAP","L","LOW","M","Q","H","DEFAULT_SIZE","DEFAULT_LEVEL","DEFAULT_BACKGROUND_COLOR","DEFAULT_FRONT_COLOR","DEFAULT_NEED_MARGIN","DEFAULT_MINVERSION","SPEC_MARGIN_SIZE","DEFAULT_MARGIN_SIZE","DEFAULT_IMG_SCALE","generatePath","margin","ops","start","cell","join","excavateModules","excavation","h","w","getImageSettings","cells","imageSettings","numCells","defaultSize","scale","width","height","opacity","excavate","floorX","floorY","ceilW","ceilH","crossOrigin","getMarginSize","needMargin","marginSize","isSupportPath2d","Path2D","addPath","_unused","useQRCode","opt","level","includeMargin","memoizedQrcode","computed","segments","cs","mg","cis","calculatedImageSettings","qrcode"],"mappings":"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"}