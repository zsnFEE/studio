/**
 * tdesign v1.15.2
 * (c) 2025 tdesign
 * @license MIT
 */

import { isVNode, Comment, Fragment } from 'vue';
import { c as commonjsGlobal, g as getDefaultExportFromCjs } from './dep-779bddf7.mjs';
import { isFunction, isString, isArray, isObject } from 'lodash-es';

var raf$2 = {exports: {}};

var performanceNow$2 = {exports: {}};

var performanceNow = performanceNow$2.exports;

// Generated by CoffeeScript 1.12.2
(function () {
  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;
  if (typeof performance !== "undefined" && performance !== null && performance.now) {
    performanceNow$2.exports = function () {
      return performance.now();
    };
  } else if (typeof process !== "undefined" && process !== null && process.hrtime) {
    performanceNow$2.exports = function () {
      return (getNanoSeconds() - nodeLoadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function getNanoSeconds() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    moduleLoadTime = getNanoSeconds();
    upTime = process.uptime() * 1e9;
    nodeLoadTime = moduleLoadTime - upTime;
  } else if (Date.now) {
    performanceNow$2.exports = function () {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    performanceNow$2.exports = function () {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }
}).call(commonjsGlobal);
var performanceNowExports = performanceNow$2.exports;
var performanceNow$1 = /*@__PURE__*/getDefaultExportFromCjs(performanceNowExports);

var raf_1 = raf$2.exports;
var now = performanceNowExports,
  root = typeof window === 'undefined' ? commonjsGlobal : window,
  vendors = ['moz', 'webkit'],
  suffix = 'AnimationFrame',
  raf = root['request' + suffix],
  caf = root['cancel' + suffix] || root['cancelRequest' + suffix];
for (var i = 0; !raf && i < vendors.length; i++) {
  raf = root[vendors[i] + 'Request' + suffix];
  caf = root[vendors[i] + 'Cancel' + suffix] || root[vendors[i] + 'CancelRequest' + suffix];
}

// Some versions of FF have rAF but not cAF
if (!raf || !caf) {
  var last = 0,
    id = 0,
    queue = [],
    frameDuration = 1000 / 60;
  raf = function raf(callback) {
    if (queue.length === 0) {
      var _now = now(),
        next = Math.max(0, frameDuration - (_now - last));
      last = next + _now;
      setTimeout(function () {
        var cp = queue.slice(0);
        // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue
        queue.length = 0;
        var _loop = function _loop() {
          if (!cp[i].cancelled) {
            try {
              cp[i].callback(last);
            } catch (e) {
              setTimeout(function () {
                throw e;
              }, 0);
            }
          }
        };
        for (var i = 0; i < cp.length; i++) {
          _loop();
        }
      }, Math.round(next));
    }
    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    });
    return id;
  };
  caf = function caf(handle) {
    for (var i = 0; i < queue.length; i++) {
      if (queue[i].handle === handle) {
        queue[i].cancelled = true;
      }
    }
  };
}
raf$2.exports = function (fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  return raf.call(root, fn);
};
var cancel = raf$2.exports.cancel = function () {
  caf.apply(root, arguments);
};
var polyfill = raf$2.exports.polyfill = function (object) {
  if (!object) {
    object = root;
  }
  object.requestAnimationFrame = raf;
  object.cancelAnimationFrame = caf;
};
var rafExports = raf$2.exports;
var raf$1 = /*@__PURE__*/getDefaultExportFromCjs(rafExports);

var linear = function linear(current, start, end, duration) {
  var change = end - start;
  var offset = change * current / duration;
  return offset + start;
};
var easeInOutCubic = function easeInOutCubic(current, start, end, duration) {
  var change = (end - start) / 2;
  var time = current / (duration / 2);
  if (time < 1) {
    return change * time * time * time + start;
  }
  time -= 2;
  return change * (time * time * time + 2) + start;
};

var isServer = typeof window === "undefined";
var trim = function trim(str) {
  return (str || "").replace(/^[\s\uFEFF]+|[\s\uFEFF]+$/g, "");
};
var on = function () {
  if (!isServer && document.addEventListener) {
    return function (element, event, handler, options) {
      if (element && event && handler) {
        element.addEventListener(event, handler, options);
      }
    };
  }
  return function (element, event, handler) {
    if (element && event && handler) {
      element.attachEvent("on".concat(event), handler);
    }
  };
}();
var off = function () {
  if (!isServer && document.removeEventListener) {
    return function (element, event, handler, options) {
      if (element && event) {
        element.removeEventListener(event, handler, options);
      }
    };
  }
  return function (element, event, handler) {
    if (element && event) {
      element.detachEvent("on".concat(event), handler);
    }
  };
}();
function once(element, event, handler, options) {
  var handlerFn = isFunction(handler) ? handler : handler.handleEvent;
  var _callback = function callback(evt) {
    handlerFn(evt);
    off(element, event, _callback, options);
  };
  on(element, event, _callback, options);
}
function hasClass(el, cls) {
  if (!el || !cls) return false;
  if (cls.indexOf(" ") !== -1) throw new Error("className should not contain space.");
  if (el.classList) {
    return el.classList.contains(cls);
  }
  return " ".concat(el.className, " ").indexOf(" ".concat(cls, " ")) > -1;
}
function addClass(el, cls) {
  if (!el) return;
  var curClass = el.className;
  var classes = (cls || "").split(" ");
  for (var i = 0, j = classes.length; i < j; i++) {
    var clsName = classes[i];
    if (!clsName) continue;
    if (el.classList) {
      el.classList.add(clsName);
    } else if (!hasClass(el, clsName)) {
      curClass += " ".concat(clsName);
    }
  }
  if (!el.classList) {
    el.className = curClass;
  }
}
function removeClass(el, cls) {
  if (!el || !cls) return;
  var classes = cls.split(" ");
  var curClass = " ".concat(el.className, " ");
  for (var i = 0, j = classes.length; i < j; i++) {
    var clsName = classes[i];
    if (!clsName) continue;
    if (el.classList) {
      el.classList.remove(clsName);
    } else if (hasClass(el, clsName)) {
      curClass = curClass.replace(" ".concat(clsName, " "), " ");
    }
  }
  if (!el.classList) {
    el.className = trim(curClass);
  }
}
var getAttach = function getAttach(node, triggerNode) {
  var attachNode = isFunction(node) ? node(triggerNode) : node;
  if (!attachNode) {
    return document.body;
  }
  if (isString(attachNode)) {
    return document.querySelector(attachNode);
  }
  if (attachNode instanceof HTMLElement) {
    return attachNode;
  }
  return document.body;
};
var getScrollContainer = function getScrollContainer() {
  var container = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "body";
  if (isString(container)) {
    return document.querySelector(container);
  }
  if (isFunction(container)) {
    return container();
  }
  return container;
};
function isWindow(obj) {
  return obj && obj === obj.window;
}
function getScroll(target, isLeft) {
  if (isServer || !target) {
    return 0;
  }
  var method = isLeft ? "scrollLeft" : "scrollTop";
  var result = 0;
  if (isWindow(target)) {
    result = target[isLeft ? "pageXOffset" : "pageYOffset"];
  } else if (target instanceof Document) {
    result = target.documentElement[method];
  } else if (target) {
    result = target[method];
  }
  return result;
}
function scrollTo(target, opt) {
  var _opt$container = opt.container,
    container = _opt$container === void 0 ? window : _opt$container,
    _opt$duration = opt.duration,
    duration = _opt$duration === void 0 ? 450 : _opt$duration,
    _opt$easing = opt.easing,
    easing = _opt$easing === void 0 ? easeInOutCubic : _opt$easing;
  var scrollTop = getScroll(container);
  var startTime = Date.now();
  return new Promise(function (res) {
    var _fnc = function fnc() {
      var timestamp = Date.now();
      var time = timestamp - startTime;
      var nextScrollTop = easing(Math.min(time, duration), scrollTop, target, duration);
      if (isWindow(container)) {
        container.scrollTo(window.pageXOffset, nextScrollTop);
      } else if (container instanceof Document || container.constructor.name === "HTMLDocument") {
        container.documentElement.scrollTop = nextScrollTop;
      } else {
        container.scrollTop = nextScrollTop;
      }
      if (time < duration) {
        raf$1(_fnc);
      } else {
        raf$1(res);
      }
    };
    raf$1(_fnc);
  });
}
function containerDom(parent, child) {
  if (parent && child) {
    var pNode = child;
    while (pNode) {
      if (parent === pNode) {
        return true;
      }
      var _pNode = pNode,
        parentNode = _pNode.parentNode;
      pNode = parentNode;
    }
  }
  return false;
}
var clickOut = function clickOut(els, cb) {
  on(document, "click", function (event) {
    if (isArray(els)) {
      var isFlag = Array.from(els).every(function (item) {
        return containerDom(item, event.target) === false;
      });
      return isFlag && cb && cb();
    }
    if (containerDom(els, event.target)) {
      return false;
    }
    return cb && cb();
  });
};
var isTextEllipsis = function isTextEllipsis(ele) {
  var _ele$clientWidth = ele.clientWidth,
    clientWidth = _ele$clientWidth === void 0 ? 0 : _ele$clientWidth,
    _ele$scrollWidth = ele.scrollWidth,
    scrollWidth = _ele$scrollWidth === void 0 ? 0 : _ele$scrollWidth;
  return scrollWidth > clientWidth;
};
var scrollSelectedIntoView = function scrollSelectedIntoView(parentEle, selected) {
  if (isServer) return;
  if (!selected || selected.offsetParent !== parentEle) {
    parentEle.scrollTop = 0;
    return;
  }
  var selectedTop = selected.offsetTop;
  var selectedBottom = selectedTop + selected.offsetHeight;
  var parentScrollTop = parentEle.scrollTop;
  var parentViewBottom = parentScrollTop + parentEle.clientHeight;
  if (selectedTop < parentScrollTop) {
    parentEle.scrollTop = selectedTop;
  } else if (selectedBottom > parentViewBottom) {
    parentEle.scrollTop = selectedBottom - parentEle.clientHeight;
  }
};
var requestSubmit = function requestSubmit(target) {
  if (!(target instanceof HTMLFormElement)) {
    throw new Error("target must be HTMLFormElement");
  }
  var submitter = document.createElement("input");
  submitter.type = "submit";
  submitter.hidden = true;
  target.appendChild(submitter);
  submitter.click();
  target.removeChild(submitter);
};
function elementInViewport(elm, parent) {
  var rect = elm.getBoundingClientRect();
  if (parent) {
    var parentRect = parent.getBoundingClientRect();
    return rect.top >= parentRect.top && rect.left >= parentRect.left && rect.bottom <= parentRect.bottom && rect.right <= parentRect.right;
  }
  return rect.top >= 0 && rect.left >= 0 && rect.bottom + 80 <= window.innerHeight && rect.right <= window.innerWidth;
}
function getElmCssPropValue(element, propName) {
  var propValue = "";
  if (document.defaultView && document.defaultView.getComputedStyle) {
    propValue = document.defaultView.getComputedStyle(element, null).getPropertyValue(propName);
  }
  if (propValue && propValue.toLowerCase) {
    return propValue.toLowerCase();
  }
  return propValue;
}
function isFixed(element) {
  var p = element.parentNode;
  if (!p || p.nodeName === "HTML") {
    return false;
  }
  if (getElmCssPropValue(element, "position") === "fixed") {
    return true;
  }
  return isFixed(p);
}
function getWindowScroll() {
  var _document = document,
    body = _document.body;
  var docElm = document.documentElement;
  var scrollTop = window.pageYOffset || docElm.scrollTop || body.scrollTop;
  var scrollLeft = window.pageXOffset || docElm.scrollLeft || body.scrollLeft;
  return {
    scrollTop: scrollTop,
    scrollLeft: scrollLeft
  };
}
function getWindowSize() {
  if (window.innerWidth !== void 0) {
    return {
      width: window.innerWidth,
      height: window.innerHeight
    };
  }
  var doc = document.documentElement;
  return {
    width: doc.clientWidth,
    height: doc.clientHeight
  };
}
var isCommentVNode = function isCommentVNode(node) {
  return isVNode(node) && node.type === Comment;
};

function withInstall(comp, alias, directive) {
  var componentPlugin = comp;
  componentPlugin.install = function (app, name) {
    app.component(alias || name || componentPlugin.name, comp);
    directive && app.directive(directive.name, directive.comp);
  };
  return componentPlugin;
}

function getDefaultNode(options) {
  var defaultNode;
  if (isObject(options) && "defaultNode" in options) {
    defaultNode = options.defaultNode;
  } else if (isVNode(options) || isString(options)) {
    defaultNode = options;
  }
  return defaultNode;
}
function getChildren(content) {
  var childList = [];
  var _innerGetChildren = function innerGetChildren(content2) {
    if (!isArray(content2)) return;
    content2.forEach(function (item) {
      if (item.children && isArray(item.children)) {
        if (item.type !== Fragment) return;
        _innerGetChildren(item.children);
      } else {
        childList.push(item);
      }
    });
    return childList;
  };
  return _innerGetChildren(content);
}
function getParams(options) {
  return isObject(options) && "params" in options ? options.params : {};
}
function getSlotFirst(options) {
  return isObject(options) && "slotFirst" in options ? options.slotFirst : false;
}

export { addClass as a, getScrollContainer as b, off as c, getScroll as d, isTextEllipsis as e, requestSubmit as f, getAttach as g, getChildren as h, isServer as i, isFixed as j, getWindowScroll as k, once as l, isCommentVNode as m, getParams as n, on as o, getDefaultNode as p, getSlotFirst as q, removeClass as r, scrollTo as s, hasClass as t, getElmCssPropValue as u, elementInViewport as v, withInstall as w, getWindowSize as x };
//# sourceMappingURL=dep-d58b61b6.mjs.map
